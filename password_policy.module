<?php
/* $Id$ */

/**
 * Help text for the password policy module.
 */
function password_policy_help($section='') {
	$output = '';
	switch ($section) {
		case "admin/modules#description":
			$output = t("Enforces a password policy on user accounts.");
			break;
		case "admin/password_policy":
			$output = '<p>' . t('The password policy module allows you to enforce a specific level of password complexity ') .
			t('for the user passwords on the system.') . '</p>';

			$hasPolicies = password_policy_get_policy_count() != 0;
			if ($hasPolicies) {
				$output .= '<p>' . t("Listed below are the currently defined password policies.  ") .
				t("If no policy is set as the default, then any password will be accepted by ") .
				t("the system (the Drupal default).") . '</p><p>' .
				t("To set a new default password policy, select the policy below and click the ") . '<i>' .
				t("Set default policy") . '</i>' . t(" button.");
			}
			else {
				$output .= '<p>' . t('No policies are currently defined.  To add a new policy, click <a href="%url">add policy</a>.', array("%url" => url('admin/password_policy/add')));
			}
			break;
		case "admin/password_policy/add":
		case "admin/password_policy/edit/" . arg(3) :
			$output = '<p>';
			if (arg(2) == 'add')
				$output .= t("Give a name and descriptive comment to your new password policy.  ");
			
			$output .= t("A specific level of required password complexity can be achieved by ") .
			t("adding minimum requirements for the constraints listed below.  If no minimum requirements are specified for a constraint, then that constraint ") .
			t("will be ignored.  Only the constraints given values will be used.") . '</p><p>' .
			t("Please note that it is very easy to specify a set of constraints which can NEVER be satisfied (eg. min length = 3, min uppercase = 3, min lowercase = 3). This ") .
			t("module can not determine these situations automatically, so be careful during the definition of your policy.") . '</p>';

			break;
	}
	return $output;
}

/**
 * Permissions for the password policy module.
 */
function password_policy_perm() {
	return array('administer password policies');
}


/**
 * Implementation of hook_menu().
 */
function password_policy_menu($may_cache) {
	$items = array();
	$edit = user_access('administer password policies');
	
	$items[] = array('path' => 'admin/password_policy',
      'title' => t('password policy'),
      'description' => t('Configures policies for user account passwords.'),
      'callback' => 'password_policy_view',
      'access' => $edit);

	$items[] = array('path' => 'admin/password_policy/add',
      'title' => t('add policy'),
      'callback' => 'password_policy_form_policy',
      'access' => $edit,
      'type' => MENU_LOCAL_TASK);

	$arg3 = arg(3);
	if (!empty($arg3) && is_numeric($arg3)) {
		$items[] = array('path' => 'admin/password_policy/edit/'. arg(3),
	          'title' => t("Edit password policy"),
	          'callback' => 'password_policy_form_policy',
	          'callback arguments' => array('id' => arg(3)),
	          'type' => MENU_CALLBACK,
	          'access' => $edit
		);
		
		$items[] = array('path' => 'admin/password_policy/delete/'. arg(3),
	         'title' => t("Delete password policy"),
	         'callback' => 'password_policy_delete',
	         'callback arguments' => array('id' => arg(3)),
	         'type' => MENU_CALLBACK,
	         'access' => $edit
		);
	}
	
	// we display the name of the policy when viewing
	$arg2 = arg(2);
	if (!empty($arg2) && is_numeric($arg2)) {
		$policy = password_policy_load_policy_by_id($arg2);

		$items[] = array('path' => 'admin/password_policy/'. $arg2,
          'title' => $policy->name,
          'callback' => 'password_policy_view',
          'callback arguments' => array('id' => $arg2),
          'type' => MENU_CALLBACK,
          'access' => $edit
		);
	}

	$items[] = array('path' => 'admin/password_policy/list',
      'title' => t('list'),
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'weight' => -10);

	return $items;
}



/**
 * Submit hook for the form on the default view for the password policy module.  From the
 * default view, the user can set a new default password policy or clear the default so
 * that no policy is active and the default drupal password mechanism takes affect.
 */
function password_policy_view_submit($form_id, $form_values) {
	$op = !empty($_POST['op']) ? $_POST['op'] : '';
	if ($op == t('Clear default')) {
		_password_policy_clear_default();
		drupal_set_message(t('No policy is active, all user passwords will be accepted (Drupal default).'));

	}
	else if ($op == t('Set default policy')) {
		$pid = $form_values['default'];
		if ($pid) {
			$policy = password_policy_load_policy_by_id($pid);
			if ($policy) {
				_password_policy_clear_default();
				db_query("UPDATE {password_policy} SET enabled = %d WHERE id = %d", 1, $pid);
				drupal_set_message(t('\'%name\' has been set as the default password policy.', array('%name' => $policy->name)));
			}
		}
	}
}

/**
 * Resets the enabled flag for all policies in the database to 0.
 *
 */
function _password_policy_clear_default() {
	db_query("UPDATE {password_policy} SET enabled = %d", 0);
}

/**
 * The default view for the password policy module. 
 */
function password_policy_view($pid = NULL) {
	
	// If we have a pid, then display the details for that policy, else
	// display all policies.
	if ($pid) {
		$policy = password_policy_load_policy_by_id($pid);
		if (!$policy) {
			drupal_goto("admin/password_policy");
		}
		$editURL = l(t('editing this policy'), 'admin/password_policy/edit/'. $pid);
		$constraints = $policy->constraints;
		$desc = !$constraints ? t('This policy has no constraints set.  You can add constraints by ') . $editURL . '.'
		: t('This policy has the constraints listed below.  You can change the constraints by ') . $editURL . '.</br>' .  $policy->getValidationErrorMessage();
		$output = "<p>$desc</p>";
		return $output;

	}
	
	// load the summary policies (id->name)
	$summaries = _password_policy_load_policy_summaries();

	if ($summaries) {
		foreach ($summaries as $summary) {
			$id = $summary['id'];
			$name = $summary['name'];
			$row = array();
			$options[$id] = '';
			if ($summary['enabled']) {
				$default_id = $id;
			}
			$form[$name]['id'] = array('#value' => $id);
			$form[$name]['view'] = array('#value' => l(t('view'), 'admin/password_policy/'. $id));
			$form[$name]['edit'] = array('#value' => l(t('edit'), 'admin/password_policy/edit/'. $id));
			$form[$name]['delete'] = array('#value' => l(t('delete'), 'admin/password_policy/delete/'. $id));
		}
		$form['default'] = array('#type' => 'radios', '#options' => $options, '#default_value' => $default_id);
		$form['submit'] = array('#type' => 'submit', '#value' => t('Set default policy'));
		$form['clear'] = array('#type' => 'submit', '#value' => t('Clear default'));
		return drupal_get_form('password_policy_view', $form);
	}
	return "";
}



/**
 * Custom theme for rendering a checkbox list of defined policies.  With Drupal's form
 * API, it can be tricky to get a layout of the form elements which is different from
 * the default.  This layout is based on a similar layout found in the "input formats"
 * module.
 */
function theme_password_policy_view($form) {
	foreach ($form as $name => $element) {
		if (!empty($element['edit']) && is_array($element['edit'])) {
			$rows[] = array(
			form_render($form['default'][$element['id']['#value']]),
			check_plain($name),
			form_render($form[$name]['view']),
			form_render($form[$name]['edit']),
			form_render($form[$name]['delete'])
			);
			unset($form[$name]);
		}
	}
	$header = array(t('Default'), t('Name'), array('data' => t('Operations'), 'colspan' => 3));
	$output = theme('table', $header, $rows);
	$output .= form_render($form);

	return $output;
}

/**
 * Confirmation form for the deletion of a password policy.  Deletion takes place
 * in password_policy_delete_submit().
 */
function password_policy_delete() {
	$pid = arg(3);
	if (!$pid) {
		drupal_not_found();
	}
	
	$policy = password_policy_load_policy_by_id($pid);

	if ($policy) {
		$form['pid'] = array('#type' => 'hidden', '#value' => $pid);
		$form['name'] = array('#type' => 'hidden', '#value' => $policy->name);

		$description = count($policy->constraints)
		? t('This policy has the following constraints:') . '<br/>' . $policy->getValidationErrorMessage()
		: t('There are no constraints specified for this policy.');

		return confirm_form(
      	'password_policy_delete', 
		$form,
		t('Are you sure you want to delete the policy \'%name\'?', array('%name' => $policy->name)),
        'admin/password_policy', 
		$description,
		t('Delete'),
		t('Cancel'));
	}
	else {
		drupal_not_found();
	}
}

/**
 * Submit hook for the delete policy operation.
 */
function password_policy_delete_submit($form_id, $form_values) {
	$pid = $form_values['pid'];
	$policy = password_policy_load_policy_by_id($pid);

	db_query("DELETE FROM {password_policy} WHERE id = %d", $pid);

	if (db_affected_rows()) {
		drupal_set_message(t('Password policy \'%policy\' was deleted.', array('%policy' => $policy->name)));
		watchdog('password_policy', t('Policy \'%name\' was deleted.', array('%name' => $policy->name)), WATCHDOG_NOTICE);
	}
	
	return 'admin/password_policy';
}

/**
 * Returns an array of constraint instances which the user should be able to 
 * have access to in their password policy.  Only the ones which the user 
 * sets a value for will be used. See password_policy_form_policy_submit().
 *
 * @return unknown
 */
function _password_policy_get_valid_constraints() {
	
	// NOTE: TO ADD A NEW CONSTRAINT
	// Create a new constraint object defined in a constraint_XXX.php file
	// in the constraints directory.  The object should extend the base
	// Constraint object class.  Then add a valid instance to the array
	// below.  
	
	// TODO the constraint objects and the way the UI work only permit
	// one parameter to be passed to the constraint object, which 
	// in all cases so far is an integer value representing the minimum
	// number of X that the password is being constrained to.  The values for
	// the constructors do not matter as long as they are valid since they will
	// be overwritten on the form submit.  Ideally we should have a separate
	// UI for each constraint type which can then allow for more complex
	// parameterization of the constraint objects, but so far this hasn't
	// been needed.
	_password_policy_load_constraint_definitions();

	return array(
	new Length_Constraint(1),
	new Letter_Constraint(1),
	new Digit_Constraint(1),
	new Letter_Digit_Constraint(1),
	new Lowercase_Constraint(1),
	new Uppercase_Constraint(1),
	new Punctuation_Constraint(1),
	new History_Constraint(),
	new Character_Types_Constraint(1));
}

/**
 * Form display for new or to be edited password policies.  
 */
function password_policy_form_policy($pid = NULL) {
	
	if ($pid) {
		$policy = password_policy_load_policy_by_id($pid);
	}

	$form['name'] = array('#type' => 'textfield',
    '#title' => t('Name'),
    '#default_value' => $policy->name,
    '#maxlength' => 64,
    '#required' => TRUE,
	);

	$form['description'] = array('#type' => 'textarea',
    '#title' => t('Description'),
    '#default_value' => $policy->description,
	);

	// Get an array of the valid constraint types available
	$constraintTypes = _password_policy_get_valid_constraints();

	$count = 1;
	foreach ($constraintTypes as $constraint) {
		$defaultValue = NULL;

		// if we are editing, then see if this constraint already has a value,
		// if so, then set that as the default value for the form
		if ($policy) {
			foreach ($policy->constraints as $policyConstraint) {
				if (get_class($policyConstraint) == get_class($constraint)) {
					$defaultValue = $policyConstraint->getMinimumConstraintValue();
				}
			}
		}
		
		$form['constraints'][get_class($constraint)] = array(
	    '#type' => 'textfield',
	    '#size' => 5,
		'#default_value' => $defaultValue,
	    '#maxlength' => 2, 
	    '#title' => t($constraint->getName()),
		'#description' => t($constraint->getDescription()),
		);
		$count++;
	}
	
	$form['submit'] = array('#type' => 'submit', '#value' => $policy ? t('Edit policy') : t('Create policy'));

	if ($policy) {
		$form['pid'] = array('#type' => 'hidden', '#value' => $pid);
	}
	
	return drupal_get_form('password_policy_form_policy', $form);
}


/**
 * Form submission hook for new or edited password policies.
 */
function password_policy_form_policy_submit($form_id, $form_values) {

	// create the policy
	_password_policy_load_constraint_definitions();

	// Here we build/re-build a new password policy using an 
	// And_Constraint object instance.  We add a constraint for
	// each type where the user entered a number for the minimum value.
	$policy = new And_Constraint();
	$policy->setName($form_values['name']);
	$policy->setDescription($form_values['description']);
	foreach ($form_values as $key => $value) {
		
		// if we have no form value, then we have no constraint to set.
		$value = trim($value);
		if ($value != "" && preg_match("/^.*constraint$/i", $key)) {
			$className = $key;
			if (class_exists($className)) {
				$constraint = new $className($value);
				$constraint->minimumConstraintValue = $value;
				$policy->addConstraint($constraint);
			}
		}
	}
	
	// if we have an id, update, else save.
	if ($form_values['pid']) {
		password_policy_update_policy($form_values['pid'], $policy);
		drupal_set_message(t('Policy \'%name\' has been updated.', array('%name' => $policy->name)));
		watchdog('password_policy', t('Policy \'%name\' updated.', array('%name' => $policy->name)), WATCHDOG_NOTICE, l(t('view'), 'admin/password_policy/' . $form_values['pid']));
	}
	else {
		password_policy_save_policy($policy);
		watchdog('password_policy', t('New policy \'%name\' added.', array('%name' => $policy->name)), WATCHDOG_NOTICE, l(t('view'), 'admin/password_policy'));
	}

	return "admin/password_policy";
}

/**
 * The implementation of hook_user().  Used to trap the validation step so 
 * we can test any currently enabled password policies.
 *
 */
function password_policy_user($type, &$edit, &$user, $category = NULL) {

	if ($category == 'account' && !empty($edit['pass'])) {
				
		if ($type == 'validate') {
			$constraint = password_policy_load_active_policy();
			if ($constraint && $constraint->validate($edit['pass'], $user) == FALSE) {
				form_set_error('pass', t('Your password must meet the following requirements:') . $constraint->getValidationErrorMessage($edit['pass'], $user));
			}
			else {
				// as long as the password policy module is enabled, we will track the hashed password values which 
				// can then be used in the history constraint.
				if ($user->uid) _password_policy_store_password($user->uid, $edit['pass']);
			
			}
		}
		else if ($type == 'insert' && !empty($edit['pass'])) {
			// new users will not yet have a uid during the validation step, but they will at this
			// insert step.  Here we store record their first password in the system for use
			// with the history constraint (if used).
			if ($user->uid) _password_policy_store_password($user->uid, $edit['pass']);
		}
	}
}

/**
 * Stores the given password associated with the user with the specified id in the database.  This
 * data is used with the history constraint to prevent users from using a password they have
 * used previously.
 */
function _password_policy_store_password($uid, $pass) {
	db_query("INSERT INTO {password_policy_users} SET uid = %d, pass = '%s', created = %d", $uid, md5($pass), time());
}

/**
 * Returns the number of unique policies defined and stored in the database.
 *
 * @return 
 * 		the number of defined policies
 */
function password_policy_get_policy_count() {
	$result = db_result(db_query("SELECT COUNT(id) FROM {password_policy}"));
	return $result[0];
}

/**
 * Saves the policy instance in the database as a new policy.
 *
 * @param $policy
 * 		The policy object instance (of type And_Constraint) to save.
 */
function password_policy_save_policy($policy) {
	$cid = db_next_id('{password_policy}_id');
	db_query("INSERT INTO {password_policy} SET id = %d, name = '%s', description = '%s', enabled = %d, serialized_policy = '%s'",
	$cid, $policy->name, $policy->description, 0, serialize($policy));

	drupal_set_message(t('Policy \'%name\' has been updated.', array('%name' =>  $policy->name)));
}

/**
 * Updates the given policy instance with the given policy id in the database.
 *
 * @param $pid
 * 		The id of the policy to update.
 * @param $policy
 * 		An object instance of type And_Constraint
 */
function password_policy_update_policy($pid, $policy) {
	db_query("UPDATE {password_policy} SET name = '%s', description = '%s', serialized_policy = '%s' WHERE id = %d",
	$policy->name, $policy->description, serialize($policy), $pid);
}

/**
 * Returns an array of associative arrays containing the keys id, name, enable and
 * description for all the password policies defined in the database ordered by name.
 *
 * @return 
 * 		An array of associative arrays.
 */
function _password_policy_load_policy_summaries() {
	$result = db_query('SELECT id, name, enabled, description FROM {password_policy} p ORDER BY name');
	while ($ary = db_fetch_array($result)) {
		$summaries[] = $ary;
	}
	
	return $summaries;
}

/**
 * Loads the default (enabled and active) policy or NULL if there
 * are no active policies.
 *
 * @return 
 * 		An And_Constraint object instance, or NULL if no active policy exists.
 */
function password_policy_load_active_policy() {
	_password_policy_load_constraint_definitions();

	$result = db_query('SELECT * FROM {password_policy} p WHERE p.enabled = %d', 1);
	if (!$result || !db_num_rows($result)) return NULL;

	$values = db_fetch_array($result);

	// fetch and unserialize the serialized policy
	return unserialize($values['serialized_policy']);
}

/**
 * Loads the policy with the specified id or NULL if not found.
 *
 * @param $id
 * 		The policy id.
 * @return 
 * 		An And_Constraint object instance, or NULL if no policy was found.
 */
function password_policy_load_policy_by_id($id) {
	_password_policy_load_constraint_definitions();

	$result = db_query('SELECT * FROM {password_policy} p WHERE p.id = %d', $id);
	if (!$result || !db_num_rows($result)) return NULL;

	$values = db_fetch_array($result);

	// fetch and unserialize the serialized policy
	return unserialize($values['serialized_policy']);
}

/**
 * Loads all the constraint object definitions.
 *
 */
function _password_policy_load_constraint_definitions() {
	$dir = dirname(__FILE__) . '/constraints';
	$constraints = file_scan_directory($dir, '^constraint.*\.php$');
	foreach ($constraints as $cFile) {
		if (is_file($cFile->filename)) {
			include_once($cFile->filename);
		}
	}
}

/**
 * Implementation of hook_simpletest() for use with the 
 * simpletest module.
 */
function password_policy_simpletest() {
	$dir = drupal_get_path('module', 'password_policy');
	$tests = file_scan_directory($dir, '\.test$');
	return array_keys($tests);
}

?>
